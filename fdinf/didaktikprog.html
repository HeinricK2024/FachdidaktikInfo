DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Portfolio-Fachdidaktik Informatik</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <link rel="stylesheet" href="../style/style.css">
</head>
<body>
  <div class="sidebar">
    <ul>
        <li><a href="../index.html"><i class="fas fa-home"></i> Startseite</a></li>
        <li>
            <a href="fachdidaktik_overview.html"><i class="fas fa-book"></i> Einführung in die Fachdidaktik Informatik</a>
            <ul>
                <li><a href="programmieren.html">Programmieren</a></li>
                <li><a href="ides.html">Entwicklungsumgebungen</a></li>
                <li><a href="objects.html">Objects First vs. Objects Later</a></li>
                <li><a href="didaktikprog.html">Didaktische Ansätze</a></li>
                <li><a href ="didaktische_ansatze.html">Evaluation von Unterrichtsmaterialien für den Informatikunterricht</a></li>
                <li><a href="gamification.html">Gamification</a></li>
                <li><a href="boolsche_algebra.html">Einführung in die Boolesche Algebra</a></li>
                <li><a href="introduction_in_scratch.html">Scratch Unterrichtseinheit</a></li>
            </ul>
        </li>
        <li>
            <a href="../didkonz/konzeptionen_overview.html"><i class="fas fa-book"></i> Didaktische Konzeptionen der beruflichen Bildung</a>
            <ul>
                <li><a href="../didkonz/albers_didaktische_modelle.html">Albers - Modelle und didaktische Konzepte in der Berufsbildung</a></li>
                <li><a href="../didkonz/geschichte_bildungsbegriff.html">Historischer Hintergrund der beruflichen Ausbildung</a></li>
                <li><a href="../didkonz/euler_wirtschaftsdidaktik.html">Euler - Theoretische Zugänge zur Wirtschaftsdidaktik</a></li>
                <li><a href="../didkonz/arnold_kompetenzbegriff.html">Arnold, Schüssler - Entwicklung des Kompetenzbegriffs</a></li>
                <li><a href="../didkonz/clement_kompetenzentwicklung.html">Clement - Kompetenzentwicklung im internationalen Kontext</a></li>
                <li><a href="../didkonz/kutscha_allgemeine_berufliche_bildung.html">Kutscha - Zum Verhältnis von allgemeiner und beruflicher Bildung im Kontext bildungstheoretischer Reformkonzepte</a></li>
            </ul>
        </li>
        <li><a href="../reflexion.html"><i class="fas fa-book"></i>Verknüpfung der beiden Veranstaltungen</a></li>
    </ul>
</div>
<main>
    <div class="container">
        <h1>Sitzung - Thema: Didaktische Ansätze zum Programmierenlernen</h1>
<h3>Aufgabenstellung</h3>
    <h3>Lesen Sie die Kurzeinführung zu didaktischen Ansätzen zum Programmierenlernen und 
        recherchieren Sie weitere, vertiefte Informationen zu den Ansätzen.</h3>
    <p>
<b>1. Lernen mit Lösungsbeispielen</b>
<br>
Dieser Ansatz stützt sich stark auf das Modell der kognitiven Meisterlehre. Lernende erhalten vollständige oder teilweise ausgearbeitete Lösungen und analysieren diese. 
Durch das Nachvollziehen der Lösungen und die Erklärungen der zugrundeliegenden Prinzipien soll es den Lernenden ermöglicht werden, diese Konzepte später auf neue 
Probleme anzuwenden. 
<br>
<b>Vertiefung:</b>
<br>
Das Lernen mit Lösungsbeispielen fördert das Verständnis von „best practices“ und ermöglicht es Lernenden, von der Expertise anderer zu profitieren (vgl. Atkinson et al., 2000, S.183). 
Studien zeigen, dass diese Methode besonders effektiv ist, wenn die Lösungen Schritt für Schritt erklärt und in Bezug zu allgemeinen Prinzipien gesetzt werden (vgl. Atkinson et al., 2000, S.190). 
Besonders im Bereich der objektorientierten Programmierung kann dies den Lernenden helfen, komplexe Abstraktionen und Designmuster besser zu verstehen. Auch im Bereich der
Mathematik wird das Lernen mit Lösungsbeispielen genutzt, um mathematische Fertigkeiten effektiv und effizient zu vermitteln (vgl. Renkl & Schworm, 2002, S.261). Die Idee dahinter ist, 
dass Studierende aus sorgfältig konstruierten und sequenzierten Lösungsbeispielen lernen können, ohne zusätzliche Instruktionen zu benötigen. Dabei kann aus Lösungsbeispielen 
die „einfache“ Anwendung von Algorithmen oder Ähnlichem erlernt und darüber hinaus ein Verständnis der Lösungslogik erreicht werden, was Transferleistungen fördert (vgl. Renkl & Schworm, 2002, S.261).
<br>
<br>
<b>2. Der Leseansatz</b>
<br>
Beim Leseansatz lernen die Studierenden, indem sie zunächst bestehende Programme lesen, analysieren und ausführen. Änderungen und Erweiterungen werden dabei schrittweise 
vorgenommen. Das Schreiben eigener Programme folgt erst nach dieser Phase.
<br>
<b>Vertiefung:</b>
<br>
Der Leseansatz wird oft als Einstiegsmethode in das Programmieren verwendet. Er ermutigt Lernende, den Code anderer zu verstehen, bevor sie selbst eigenen Code schreiben. 
Beim Leseansatz geht es nicht nur darum, Code zu schreiben, sondern auch darum, ihn zu verstehen (vgl. Schulte et al., o. D., S.317). 
Programmieren wird als Denkweise betrachtet, die zur Lösung von Problemen führt (vgl. „Programmieren – Unterrichtsmaterial“, o. D.). Debugging ist hier ein zentraler Bestandteil, 
da es den Lernenden hilft, die Dynamik des Codes zu verstehen, da das Verstehen von Programmen schrittweise von der Konstruktebene bis hin zur Makroebene erfolgt 
(vgl. Schulte et al., o. D., S.312). Ausgehend von diesem Erlangten Verständnis des Codes kann dieser modifiziert und erweitert werden 
(vgl. „Programmieren – Unterrichtsmaterial“, o. D.).
<br>
<br>
<b>3. Der Expertenansatz</b>
<br>
Beim Expertenansatz beginnen die Lernenden direkt mit einem relativ komplexen Projekt. Sie erwerben das notwendige Wissen schrittweise, indem sie Probleme lösen, die während der 
Projektentwicklung auftreten.
<br>
<b>Vertiefung:</b>
<br>
Der Expertenansatz ist eine Methode zur Unterrichtung von Programmierung, die sich auf das Algorithmen- und Programmdesign konzentriert (vgl. „Programmieren – Unterrichtsmaterial“, o. D.). 
Es handelt sich hierbei um einen Top-Down-Ansatz, bei dem Anfänger mit einem komplexen, aber motivierenden Programmierproblem beginnen. Sie verfeinern schrittweise das Problem, bis sie 
die eigentliche Sprachebene erreichen. Dabei sollen Schüler wiederkehrende Programmabschnitte und Modelle erkennen. Anstatt große Aufgaben zu lösen, sollten Schüler viele kleine Schritte 
machen (vgl. „Programmieren – Unterrichtsmaterial“, o. D.). Fehler sind Teil des Prozesses, und Code muss manchmal umgeschrieben werden. Der Experteansatz fördert das Verständnis von 
Algorithmen und Design und ermöglicht es den Lernenden, schrittweise komplexe Probleme zu lösen. 
<br>
<br>
<b>4. Der Spiralansatz</b>
<br>
Beim Spiralansatz wird der Lernstoff schrittweise vertieft, indem syntaktische und semantische Elemente einer Programmiersprache nacheinander eingeführt und durch Übungsprogramme 
gefestigt werden.
<br>
<b>Vertiefung:</b>
<br>
Dieser Ansatz orientiert sich am Konzept des „Spiralcurriculums“ nach Bruner, bei dem komplexere Konzepte erst eingeführt werden, wenn die grundlegenden Elemente verstanden wurden 
(vgl. Van Merriënboer et al., 2019, S.6). Für das Programmieren bedeutet dies, dass Lernende immer komplexere Programme schreiben, während sie 
ihre Fertigkeiten und ihr Verständnis weiterentwickeln(vgl. „Programmieren – Unterrichtsmaterial“, o. D.). Der Spiralansatz ermöglicht es, Konzepte iterativ zu vermitteln. Lernende 
werden zunächst in grundlegende Programmierstrukturen eingeführt, wie etwa Variablen und Schleifen. Diese werden in kleinen, schrittweisen Zyklen vertieft und erweitert. Beispielsweise 
könnte man in der ersten Runde einfache Schleifen in Python einführen und in späteren Runden komplexere Schleifenstrukturen wie verschachtelte Schleifen oder rekursive Funktionen behandeln.
Vorteilhaft ist, dass der Spiralansatz auf Wiederholung und Anwendung basiert, was das Verständnis und die Verinnerlichung komplexer Konzepte fördert.
Beispielsweise ermöglicht es die Verwendung von „JavaKara“, den Lernenden Schritt für Schritt in die grundlegenden Konzepte eingeführt zu werden. Zuerst werden einfache Anweisungen und 
Methoden gelernt, bevor komplexere Strukturen wie Schleifen und Variablen hinzukommen („SwissEDUC - Informatik - Programming: Grundlegende Programmierkonzepte“, o. D.).
<br>
<br>

<h3>Programmieren als Prozess</h3>
Die Komplexität des Programmierens wird durch das Zusammenspiel verschiedener Fähigkeiten und Modelle verdeutlicht. Um diesen Prozess zu unterstützen, wurden unterschiedliche didaktische 
Ansätze entwickelt, darunter das Live-Coding, das es Lernenden ermöglicht, den gesamten Prozess des Programmierens zu beobachten und nachzuvollziehen.
<br>
<br>
<b>5. Live-Coding</b>
<br>
Live-Coding ermöglicht es, den Lernenden den gesamten Entwicklungsprozess eines Programms in Echtzeit zu demonstrieren. Der Lehrende programmiert vor den Lernenden und kommentiert dabei 
seine Schritte. So werden der Denkprozess, die Problemlösungsstrategien und das Debugging direkt sichtbar.
<br>
<b>Vertiefung:</b>
<br>
Live-Coding hilft besonders Anfängern, den Programmierprozess als dynamisch und inkrementellen Prozess zu verstehen (Raj et al., 2018, S.1). Die Live-Codierung ist ein Ansatz zur 
Vermittlung von Programmierung, bei dem der Dozent während des Unterrichts tatsächlichen Code schreibt. Lernende sehen in Echtzeit, wie ein Programm entwickelt wird. Dies hilft, 
den abstrakten Code greifbarer zu machen und den Denkprozess eines erfahrenen Programmierers nachzuvollziehen (Raj et al., 2018, S.7). Die Studie zeigt, dass Live-Codierung den Programmierprozess für Anfänger 
verständlicher macht, beim Erlernen des Debugging-Prozesses hilft und die Studierenden mit guten Programmierpraktiken vertraut macht (Raj et al., 2018, S.1). 
Die Schüler bevorzugen es, während einer Live-Codierungssitzung zusammen mit dem Dozenten zu programmieren, anstatt nur Zuschauer zu sein (Raj et al., 2018, S.8). Dieser Ansatz kann dazu beitragen, die Lücke zwischen 
Theorie und Praxis in der Programmierung zu schließen und den Schülern zu helfen, ihre Fähigkeiten zu verbessern.
</p>

<h3>Quellen</h3>
<li><i>Fachdidaktik Informatik. (o. D.). Abgerufen von <a href= "https://informatik-franke.de/lehre/sose/fadiinf/u4.html" >"https://informatik-franke.de/lehre/sose/fadiinf/u4.html" </a></i></li>
<li><i>Renkl, A. & Schworm, S. (2002). Lernen, mit Lösungsbeispielen zu lehren. In Prenzel, Manfred & Doll, Jörg (Hrsg.), Bildungsqualität von Schule: Schulische und außerschulische Bedingungen mathematischer, naturwissenschaftlicher und überfachlicher Kompetenzen (S. 259–270). book-chapter, Beltz. Abgerufen von <a href="https://www.pedocs.de/volltexte/2011/3951/pdf/ZfPaed_45_Beiheft_Renkl_Schworm_Lernen_Loesungsbeispiele_D_A.pdf" >"https://www.pedocs.de/volltexte/2011/3951/pdf/ZfPaed_45_Beiheft_Renkl_Schworm_Lernen_Loesungsbeispiele_D_A.pdf" </a></i></li>
<li><i>Atkinson, R. K., Derry, S. J., Renkl, A., & Wortham, D. (2000). Learning from examples: Instructional principles from the worked examples research. Review of educational research, 70(2), 181-214.. Abgerufen von <a href= "https://assess.ucr.edu/sites/default/files/2019-02/atkinsonderryrenklwortham_2000.pdf" >"https://assess.ucr.edu/sites/default/files/2019-02/atkinsonderryrenklwortham_2000.pdf" </a></i></li>
<li><i>Programmieren – Unterrichtsmaterial. (o. D.). Abgerufen von <a href= "https://unterrichtsmaterial-ddi.cs.upb.de/Programmieren" >"https://unterrichtsmaterial-ddi.cs.upb.de/Programmieren" </a></i></li>
<li><i>Schulte, C., Didaktik der Informatik & Freie Universität Berlin. (o. D.). Abgerufen von <a href= "https://subs.emis.de/LNI/Proceedings/Proceedings112/gi-proc-112-027.pdf" >"https://subs.emis.de/LNI/Proceedings/Proceedings112/gi-proc-112-027.pdf" </a></i></li>
<li><i>Van Merriënboer, J. J. G., Maastricht University & Jimmy Frerejean. (2019). The Four-Component Instructional Design Model: An Overview of its Main Design Principles. Abgerufen von <a href= "https://www.4cid.org/wp-content/uploads/2021/04/vanmerrienboer-4cid-overview-of-main-design-principles-2021.pdf" >"https://www.4cid.org/wp-content/uploads/2021/04/vanmerrienboer-4cid-overview-of-main-design-principles-2021.pdf" </a></i></li>
<li><i>SwissEduc: Programming: Grundlegende Programmierkonzepte. Abgerufen von <a href= "https://www.swisseduc.ch/informatik/120-lektionen/practices/programming/javakara/index.html" >"https://www.swisseduc.ch/informatik/120-lektionen/practices/programming/javakara/index.html" </a></i></li>
<li><i>Raj, A. G. S., Patel, J. M., Halverson, R., & Halverson, E. R. (2018). Role of Live-coding in Learning Introductory Programming. Proceedings of the 18th Koli Calling International Conference on Computing Education Research.. Abgerufen von <a href= "https://pages.cs.wisc.edu/~gerald/papers/LiveCoding.pdf" >"https://pages.cs.wisc.edu/~gerald/papers/LiveCoding.pdf" </a></i></li>
    </div>
  </main>

  <footer>
    <div class="footer-content">
      <div class="impressum">
        <p>Heinrich Krug | heinrich.krug@stud.ph-weingarten.de</p>
      </div>
    </div>
  </footer>
  
  <!-- Einbinden der externen JavaScript-Datei -->
  <script src="../script/script.js"></script>
</body>
</html>
